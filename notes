-- look at source codes for CSS reference
-- good data model
-- think about using views, joins, maps, functions, triggers and procedures, normalization, and good queries, transactions, indices

-- real time synchronization, dealing with data loss while sending message, channels, joining tables with foreign key. 
-- keep schema and make table queries modularized.
-- store user-name and password and link the user name to messaging table
-- multiple chat rooms and selective broadcasting

-- messages should load on start from server
-- ids should not change with new connection. Storing usernames would be better.
-- time stamps say time not numeric string
-- register users and store userid to verify with every connection


-- build a basic chat app without authentication

Todo:
-- password, username registration
-- password validation (using regex)
-- check if user already exists
-- use mongoose
-- bcrypt, hash and salt

-- while registering check if email already there on list
 
-- stateless vs stateful authentication
-- JWT tokens and sessions
-- Sessions:
    -- session id, opaque ref
    -- server stores id as cookie (signed with secret key, protected with flags ) keeps verifying it during the session.
    -- when user logged out. session id destroyed.

-- cookies: signed with secret, rarely AES encrypted, URL encoding for compatibility
    -- cookie header: something like sess_id=<hash>, path, domain, expiration (can only be used until expiry) attributes
    -- flags:
        -- httpOnly, Secure, SameSite (no CORS sharing)
        -- CSRF:
            -- unauthorized actions on behalf of authenticated user
            -- mitigated with CSF token

-- Tokens:
    -- stired client side, generated and sent from server
    -- stateless
    -- can be opaque, or self contained(containing important user data in its payload)
    -- reduces database lookups but exposes data to XSS (cross site scripting attack)
    -- sent in authorization header
    -- server sends access and refresh tokens 
    -- can be refreshed when about to expire
    -- SPAs, web apps.

-- JWT:

-- Pros and Cons etc:

-- HTTP authentication mechanism (MDN):
    -- client request
    -- server respond with 401, how to authorize with WWW-Authenticate res header
    -- usually client provids password prompt and then requests for authorization header.
    -- client Authorization header
    -- The basic authentication scheme sends credentials that are encoded but not encrypted. Insecure unless HTTPS/TLS
    -- Proxy authentication has different status codes (407) and headers for proxy servers.
    -- access forbidden, when provided authorizayion iant enough (403, 404)
    -- a bug with cross origin images triggering http authentication dialogs is fixed now. user credentials could be stolen.
    -- WWW-authenticate and proxy0authenticate etc header say which authentication method is used.
    -- Authorization header: <type><credentials>

-- Client and server side web socket:
    -- client side:
        -- Websocket object constructor and methods to send and receive messages, headers and all
